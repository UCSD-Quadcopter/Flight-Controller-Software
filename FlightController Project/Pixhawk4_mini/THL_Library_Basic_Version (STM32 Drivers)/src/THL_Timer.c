#include "THL_Timer.h"


#ifdef HAL_TIM_MODULE_ENABLED

#define Max_Num_TIMs 20
uint16_t numActiveTIMs = 0;
TIM* ActiveTIMs[Max_Num_TIMs];

//Each section below has its own instantiation


/*=======================Universal Functions================================*/
/**This section is aimed for timer that multitasks, if a timer
  *is solely focus on e.g. pwm generation, go to PWM Generation
  *in another section below
  */
/**
 * Please use STM32CubeMx to config period and prescaler
 */
TIM *newTIM(TIM* instance, TIM_HandleTypeDef *htim) {
	instance->htim = htim;
	for(int i = 0; i < numActiveTIMs; i++)
		if(ActiveTIMs[i]->htim == htim) {
			ActiveTIMs[i] = instance;
			return instance;
		}
	ActiveTIMs[numActiveTIMs++] = instance;
	return instance;
}
/*===========================================================================*/



/*==============================PWM Generation===============================
 *======================(a.k.a) Output Compare===============================*/


/** PWM Frequency Explaination
 *  - Timer frequency and PWM frequency are two distinct concepts!
 *    [SystemCoreClock] => [TimerClock/Freq] => [pwm_frequency]  (signals are produced from left to right).
 *    Timer clock is system clock divided by a division factor.
 *    Timer clock determines the frequency of each timer tick.
 *
 *    PWM signals are generated by setting a counter value <= ([Max_Count], a.k.a [timer period]), this
 *    counter value is what gets written to TIM->CCRx register. The timer output compare (a hardware function)
 *    pulls the signal line HIGH until the counter counts up to this TIM->CCRx value, and then pull it LOW till
 *    Max_Count. Technically, the [PwmDutyCircle] = [CCR] / [Max_Count] (in percentage).
 *
 * 	- The [TimerPrescaler] corresponds to a register that can be configured to set the desired timer frequency
 * 	  by dividing the "APB bus clock" scaled from [SystemCoreClock], a.k.a [HCLK_Frequency], with the TimerPrescaler value.
 * 	  Details of the clock relations can be looked up in STM32CubeMx software's clock configuration section,
 * 	  where a clock tree is presented.
 *
 * 	- [TimerMaxFrequency] = [HCLK] / [APBx_Bus_DivisionFactor] = [APBx_Bus_Frequency].
 *
 * 	- [TimerPrescaler] = [TimerMaxFrequency] / [TimerFrequency:(the desired frequency by user)].
 *
 * 	- [TimerFrequency:(desired)] = [Max_Count:(refer to 2nd paragraph)] * [pwm_frequency:(desired)].
 * 	  Basically the timer frequency is determined both by max count and pwm frequency,
 * 	  where the max count determines the resolution of this pwm signal.
 *
 * 	- [Max_Count] * [pwm_frequency] must be <= [TimerMaxFrequency], increasing PWM_Freq makes the driver
 * 	  respond quicker at the cost of resolution, while increasing the maximum counter value gives a higher
 * 	  resolution as the expense of responsiveness.
 *
 * 	- Turning the frequency down saves power consumption, but it usually dosen't matter.
 *
 * 	- For regular DC motor, 1kHZ-10kHZ is recommended in general.
 *
 * 	- For drone ESCs, frequency is much lower, refer to the ESC datasheet.
 *
 */

/* Pseudo-Constructor for TIM instance specifically for PWM generation
 * Warning: This constructor can only be applied for timers in which all channels
 * are used for pwm generation, otherwise, make more customized configuration via newTIM() above
 * */
TIM *newTIM_PWM(TIM* instance, TIM_HandleTypeDef *htim, uint32_t max_count, uint32_t pwm_frequency) {
	instance->htim = htim;
	timSetPwmFrequency(instance, max_count, pwm_frequency);

	//initialize
	timSetPwmDutyCircle(instance, TIM_Channel_1, 0);
	timSetPwmDutyCircle(instance, TIM_Channel_2, 0);
	timSetPwmDutyCircle(instance, TIM_Channel_3, 0);
	timSetPwmDutyCircle(instance, TIM_Channel_4, 0);

	for(int i = 0; i < numActiveTIMs; i++)
		if(ActiveTIMs[i]->htim == htim) {
			ActiveTIMs[i] = instance;
			return instance;
		}
	ActiveTIMs[numActiveTIMs++] = instance;
	return instance;
}

/*Set PWM frequency in runtime*/
void timSetPwmFrequency(TIM* instance, uint32_t max_count, uint32_t pwm_frequency) {
	uint32_t APBx_DivFactor;
	volatile uint32_t CLK_DIV = __HAL_TIM_GET_CLOCKDIVISION(instance->htim);
	if(CLK_DIV == TIM_CLOCKDIVISION_DIV1) APBx_DivFactor = 1;
	if(CLK_DIV == TIM_CLOCKDIVISION_DIV2) APBx_DivFactor = 2;
	if(CLK_DIV == TIM_CLOCKDIVISION_DIV4) APBx_DivFactor = 4;

	double TimerMaxFrequency = HAL_RCC_GetHCLKFreq() / APBx_DivFactor;
	double TimerFrequency = max_count * pwm_frequency;
	if(TimerFrequency > TimerMaxFrequency) {
		throwException("THL_Timer.c: setPwmFrequency() | max_count * pwm_frequency must be less or equal than TimerMaxFrequency");
		return;
	}
	instance->TimerPrescaler = TimerMaxFrequency / TimerFrequency;
	instance->max_count = max_count;
	__HAL_TIM_SET_AUTORELOAD(instance->htim, instance->max_count);
	__HAL_TIM_SET_PRESCALER(instance->htim, instance->TimerPrescaler);
}

/**
 * @param  Channel TIM Channels to be enabled.
 *         This parameter can be one of the following values:
 *           @arg TIM_Channel_1
 *           @arg TIM_Channel_2
 *           @arg TIM_Channel_3
 *           @arg TIM_Channel_4
 */
void timPwmGenBegin(TIM* instance, uint32_t channel) {
	HAL_TIM_PWM_Start(instance->htim, channel);
}

void timSetPwmDutyCircle(TIM* instance, uint32_t channel, uint32_t dutyCircleCnt) {
	__HAL_TIM_SET_COMPARE(instance->htim, channel, dutyCircleCnt);
}

//Pretty straightforward
void timPwmWrite(TIM* instance, uint32_t channel, double dutyCirclePercent) {
	timSetPwmDutyCircle(instance, channel, (uint32_t)(dutyCirclePercent * (double)instance->max_count));
}
/*=========================================================================*/

/*=============================Input Capture===============================*/

/*=========================================================================*/




#ifdef fixthemlater


void setPwmDutyCircle(TIM_HandleTypeDef* htimx, uint32_t channel, uint32_t dutyCircleCnt) {
	//equivalent to htimx->instance->CCRx = dutyCircle
	__HAL_TIM_SET_COMPARE(htimx, channel, dutyCircle);
}

void pwm(TIM_HandleTypeDef* htimx, uint32_t channel, double dutyCirclePercent) {
	uint32_t cnt = (int)(dutyCirclePercent * (double)htimx->CounterPeriod);
	setPwmDutyCircle(htimx, channel, cnt);
}






#ifdef xxx
/***************************Input Capture*********************************/
volatile int PulseWidth[NumTimers + 1][NumChannel + 1] = {0};
volatile int PulseWidthtmp[NumTimers + 1][NumChannel + 1] = {0};

/*******Input Capture Blocking Mode**********/
volatile int *startInputCapture(TIM_HandleTypeDef* htimx, uint32_t channel) {
	if(HAL_TIM_IC_Start(htimx, channel) != HAL_OK) Error_Handler2();
	return PulseWidth[TIMx(htimx)];
}
int getTimCapturedVal(TIM_HandleTypeDef* htimx, uint32_t channel) {
	return (int)HAL_TIM_ReadCapturedValue(htimx, channel);
}
void MeasurePulseWidth(TIM_HandleTypeDef* htimx, uint32_t channel, uint32_t MaxDelay_us) {
	uint32_t t0 = micros(); 
	int tmp_IC_CapVal = getTimCapturedVal(htimx, channel);
	while(getTimCapturedVal(htimx, channel) == tmp_IC_CapVal) if(micros() - t0 > MaxDelay_us) return;
	tmp_IC_CapVal = getTimCapturedVal(htimx, channel);
	while(getTimCapturedVal(htimx, channel) == tmp_IC_CapVal) if(micros() - t0 > MaxDelay_us) return;
  PulseWidth[TIMx(htimx)][chDec(channel)] = getTimCapturedVal(htimx, channel) - tmp_IC_CapVal;
}
/********************************************/



/*******Input Capture Interrupt Mode*********/
volatile uint8_t TIM_IC_IT_index[NumTimers + 1][NumChannel + 1] = {0};
volatile uint8_t TIM_IC_IT_Channel[NumTimers + 1][NumChannel + 1] = {INACTIVE};
volatile int *startInputCapture_IT(TIM_HandleTypeDef* htimx, uint32_t channel) {
	if(HAL_TIM_IC_Start_IT(htimx, channel) != HAL_OK) Error_Handler2();
	TIM_IC_IT_index[TIMx(htimx)][chDec(channel)] = 0;
	TIM_IC_IT_Channel[TIMx(htimx)][chDec(channel)] = ACTIVE;
	return PulseWidth[TIMx(htimx)];
}
void stopInputCapture_IT(TIM_HandleTypeDef* htimx, uint32_t channel) {
	HAL_TIM_IC_Stop_IT(htimx, channel);
	TIM_IC_IT_Channel[TIMx(htimx)][chDec(channel)] = INACTIVE;
}
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htimx)
{
	for(int channel = 1; channel <= NumChannel; channel++) {
		if(TIM_IC_IT_Channel[TIMx(htimx)][channel] == INACTIVE) continue;
		if(TIM_IC_IT_index[TIMx(htimx)][channel] == 0) {
			PulseWidthtmp[TIMx(htimx)][channel] = (int)HAL_TIM_ReadCapturedValue(htimx, chEnc(channel));
			TIM_IC_IT_index[TIMx(htimx)][channel] = 1;
		}
		else if(TIM_IC_IT_index[TIMx(htimx)][channel] == 1) {
			PulseWidth[TIMx(htimx)][channel] = 
				(int)HAL_TIM_ReadCapturedValue(htimx, chEnc(channel)) - PulseWidthtmp[TIMx(htimx)][channel];
			TIM_IC_IT_index[TIMx(htimx)][channel] = 0;
		}			
	}
}
/**********************************************/
int getInputCapturePulseWidth(TIM_HandleTypeDef* htimx, uint32_t channel) {
	return PulseWidth[TIMx(htimx)][chDec(channel)];
}
int TIM_ICval(TIM_HandleTypeDef* htimx, uint32_t channel) {
	return PulseWidth[TIMx(htimx)][chDec(channel)];
}
uint8_t isChannelActive(TIM_HandleTypeDef* htimx, uint32_t channel) {
	return TIM_IC_IT_Channel[TIMx(htimx)][channel];
}
/*************************************************************************/

#endif
#endif

#endif


